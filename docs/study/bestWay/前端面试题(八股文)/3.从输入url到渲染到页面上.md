# 3.从输入 url 到渲染到页面上(1)

<br/>

<details>
<summary>1. url 纠错/补全/特殊字符的转换</summary>
</details>

<details>
<summary>2. DNS 解析</summary>

1. 先在本地 hosts 文件查找。
2. 再去本地 dns 缓存查找
3. 再去 dns 服务器一层一层向上请求

</details>

<details>
<summary>3. TCP 三次握手连接</summary>

1. SSL 握手 +三次握手过程 (待完善)
2. 发送请求

</details>

<details>
<summary>4.服务器处理请求，并响应</summary>

#### 服务器处理请求，并响应

1. 代理服务器(反向代理到应用服务)： 负载均衡、静态资源处理、处理 ssl 加密解密、请求过滤
2. 请求参数处理与查询数据库(sql 或者 redis)

</details>

<details>
<summary>5.浏览器收到响应的处理</summary>

1. 首先处理响应头

   - 状态码
   - `set-cookie`
   - `content-type` 处理数据类型
   - 缓存: 302 状态码
     1. **协商缓存的触发条件**：强缓存（`Cache-Control`/`Expires`）失效后，浏览器携带缓存标识向服务器发起验证请求。
     2. **核心标识对**：`Last-Modified/If-Modified-Since`（基于时间）和`ETag/If-None-Match`（基于内容，优先级更高）。
   - connection： keep-alive (保活:是否断开连接)

2. 再流式处理响应数据
3. 响应体结束，如果不保活，TCP 四次挥手断开连接

</details>

<details>
<summary>6.浏览器接收数据并渲染过程</summary>

> [参考](https://www.bilibili.com/list/watchlater/?bvid=BV1k5oCYrE81&oid=114215276779641&watchlater_cfg=%7B%22viewed%22%3A0,%22key%22%3A%22%22,%22asc%22%3Afalse%7D&spm_id_from=333.881.0.0)

1. 解析。自上而下进行解析并加载
   a. 预处理线程： `dns-prefetch`、`preconnect(tcp 预连接)`
   b. 资源类型：cdn、外链
   c. 资源描述符：`async`、`defer`、`prefetch`、`preload`、`dns-prefetch`、`preconnect`(tcp 预连接)
2. 解析会生成 `DOM` 树 + `CSSOM` 树 (遇到 script 标签则会阻塞渲染,优先解析)
3. 构建渲染树 (结合 DOM 和 CSSOM, 只包含可见节点)
4. 样式计算与布局渲染 `render layout` (这里仅渲染可见元素. display:none;不渲染)(计算节点的尺寸/位置)
5. 绘制 `painter` (主线程结束...)

6. tiles 分块 （合成线程开始...）
7. 栅格化
8. 合成 -> gpu -> 绘制

---

基于渲染的浏览器优化(js 的执行/布局/绘制 都是在主线程进行)

- 减少 dom 操作(批量更新) `DocumentFragment` `requestAnimationFrame()`
- 动画优化. 在 BFC(重排和重绘的范围) 内执行, 选择 css 动画(gpu 加速)而非 js 动画
- 使用懒加载技术/避免一次加载太多内容
- web worker 任务分流

</details>
